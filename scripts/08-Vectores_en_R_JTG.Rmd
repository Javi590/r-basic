---
title: "08_Vectores_en_R_JTG"
author: "JTG"
date: "31/1/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Cómo definir un vector en R:

$\cdot$ C(): para definir un vector.

$\cdot$ scan(): para definir un vector.

$\cdot$ fix(x): para modificar visualmente el vector x.

$\cdot$ rep(a,n): para definir un vector constante que contiene el dato a repetido n veces.



c(1,2,3) #columnas

scan() #Para escanear datos que escribamos por consola

fix(x) # Cuando tenemos un vector definido en una variable x. Podemos hacer fix de x para modificar visualmente el vector x con nuestro editor de texto favorito.

rep(5,7) #Para repetir el mismo numero, caracter, elemento, n veces.

### No puede haber un vector con tipos de elementos mezclados:

$\cdot$ logical: TRUE or FALSE

$\cdot$ integer: números enteros $Z$

$\cdot$ numeric: números reales $R$

$\cdot$ complex: numeros complejos $C$

$\cdot$ character: palabras

EL orden de conversión entre tipos es el inverso del mostrado arriba: de character -> complex -> numeric -> integer -> logical

Si tenemos mezclas heterogéneas, se convertirirá en el tipo de dato superior en dicha escala.

La función scan() tiene distintos separadores en función del tipo de dato utilizado. Por ejemplo, para caracteres es un espacio, y para decimales un punto ("."). Si prevemos que los datos van a usar un separador diferente lo podemos indicar con: scan(dec=","), si vamos a usar una base de datos que utiliza separadores con coma, y no con punto.


También podemos predeterminar el tipo de datos que cogeremos y que luego transformará la función scan() con scan(what="character")

```{r prueba_vectores, echo=TRUE}
#Escribe tu año de nacimiento 10 veces:
rep(1990,10)

# Define un vector llamado vec con los siguientes datos: 16  0  1 20  1  7 88  5  1  9

vec<- c (16,  0,  1, 20,  1,  7, 88,  5 , 1,  9)

#Y modificar la cuarta posición por nuestro año de nacimiento:

fix(vec)
vec

scan(what = "character")
# 1: Javier Pepe Manolo
#"Javier" "Pepe"   "Manolo"

```

## Aplicar funciones a elementos de un vector (Operaciones vectoriales):

Para sumar, multiplicar,elevar... los elementos de un vector se puede hacer directamente:

```{r operar_con_elementos_de_un_vector, echo=TRUE}
x <- 1:10
x
x+pi
x*pi
sqrt(x)
2^(x)
x^2
```
Sim embargo, a veces no es posible aplicar la funcion concreta directamente a un vector pasandolo como un argumento.

Cuando queremos aplicar una funcion a cada uno de los elementos de un vector, pero no se puede hacer directamente. Utilizamos la funcion sapply(nombre_de_vector, FUN= nombre_funcion):


```{r funcion_sapply, echo=TRUE}

sapply(x, FUN = function(elemento){sqrt(elemento)})

# Otro ejemplo, con regresión lineal (coeficiente de determinación). CUando hago directamente la regresion lineal de una serie de puntos lo que quiero ver es si se ajustan a la nube de puntos de una recta:

cd= function(x){summary(lm((1:4)~c(1:3,x)))$r.squared}

cd(4) # Da error, porque sería una recta perfecta (1-1,2-2, 3-3, 4-4)
cd(5) #El coeficiente de determinación es 0.9657143
cd(x) #No se puede aplicar una funcion que he inventado en un vector. Solo se puede aplicar en variables. Solo se puede con sapply:

sapply(x, FUN = cd)
```
### Funciones que podemos aplicar a vectores:

$\cdot$ length(x): Calcula la longitud de un vector.

$\cdot$ max(x): calcula el máximo del vector.

$\cdot$ min(x): calcula el minimo del vector.

$\cdot$ sum(x): calcula la suma de las entradas del vector.

$\cdot$ prod(x): calcula el producto de las entradas del vector.

$\cdot$ mean(x): calcula la media aritmética de todas las entradas del vector.

$\cdot$ diff(x): calcula el vector formado por las diferencias sucesivas entre entradas del vector original x. EL primero restado al segundo, el segundo al tercero, el tercero al cuarto...

$\cdot$ cumsum(x): calcula el vector formado por las sumas acumuladas de las entradas del vector original x:
 - permite definir sucesiones descritas mediante sumatorios.
 - Cada entrada de cumsum(x) es la suma de las entradas de x hasta su posición.

```{r ejemplos_funciones_y_vectores, echo=TRUE}

cuadrado = function(x){x^2}
v = c(1,2,3,4,5,6)
sapply (v, FUN = cuadrado)

mean(v) #media aritmetica de las entradas: 3.5

cumsum(v) # sumas acumuladas: 1  3  6 10 15 21
```
#### Funciones para ordenar los elementos de un vector:


$\cdot$ sort(x): Ordena el vector en orden natural de los objetos que lo forman: orden numerico creciente, orden alfabético...

$\cdot$ rev(x): invierte el orden de los elementos del vector (pero no los ordena, el primero al ultimo, y así)

```{r}
v2= c(1,5,6,2,8,3)
sort(v2) #1 2 3 5 6 8
rev(v2) # 3 8 2 6 5 1
```
```{r ejercicio_funciones_y_vectores, echo=TRUE, results='hold'}
# Combina las dos funciones anteriores, sort y rev para crear una funcion que dado un vector x os lo devuelva ordenado en orden decreciente:

rev(sort(v2)) #8 6 5 3 2 1

#Razona si aplicar primero sort y luego rev a un vector x daría en eneral el mismo resultado que aplicar primero rev y luego sort.

## Sería distinto, ya que el primero ordena lógicamente y el segundo invierte el orden del vector original.

# Investiga la documentacion de la funcion sort (recuerda que puedes usar la sintaxis __?sort__ en la consola) para leer si cambiando algún argumento de la misma podéis obtener el mismo resultado que has programado en el primer ejercicio:
?sort

## Se puede invertir el orden de sort(x) incluyendo el atributo decreasing=TRUE:

sort(v2, decreasing = TRUE) #8 6 5 3 2 1
```


## Progresiones aritméticas (para generar vectores)

$seq(a,b, by=d)$: Para generar una progresión aritmética de diferencia d que empieza en a hasta llegar a b.

$seq(a,b, length.out=n)$: define progresión aritmética de longitud n que va de a hasta b con diferencia d. Por tanto $d= (b-a)/(n-1)$

$seq(a,by=d, length.out=n)$: define la progresión aritmética de longitud n y diferencia d que empieza en a.

$a:b$: define la secuencia de números enteros $Z$ consecutivos entre dos números a y b.

```{r ejercicios_secuencias, echo=TRUE, results='asis'}
#Imprime los números del 1 al 20
1:20

#Imprime los 20 primeros números pares:

seq(2, length.out = 20, by=2)

#Imprime 30 números equidistantes entre el 17 y el 98, mostrando solo 4 cifras significativas:

round(seq(17,98, length.out = 30),digits= 4)

```
## Ejercicio práctico: El binomio de Newton (08.1)

# Subvectores

$\cdot$ vector [i]; da la i-ésima parte del vector

  - Los íncides en R empiezan en 1.
  
  - vector[length(vector)]: nos da la última entrada del vector.
  
  - vector[a:b]: si a y b son números naturales, nos da el subvector con las entradas vector original que van de la posición a-ésima hasta b-ésima.
  
  - vector[-i] Si i es un numero, este subvector está formado por todas las entradas del vector original menos la entrada i-ésima. Si i resulta ser un vector,           entonces es un vector de índices y crea un nuevo vector con las entradas del vector original, cuyos índdices pertenecen a i.
  
  - vector[-x]: Si es un vector (de índices), entonces este es el complementario de vector[x]

### También podemos utilizar operadores lógicos:

- ==: $=$
- !=: $\ne$
- >= :$\ge$
- <= : $\le$
- < : $<$
- > : $>$
- ! : No lógico
- & : Y lógico
- | : O lógico


```{r ejemplos_subvectores, echo=TRUE}

v= c(14,5,6,19,32,0,8)
v[2] #Posición 2 del vector v

v[-c(3,5)] #Vector menos los colocados en la columna 3 y 5 (6 y 32 no aparecen)

v[v != 19 & v>15] #Filtro que el propio vector sea diferente de 19 y menor que 15 es el 32.
```

#### Condicionales

- which (x cumple condición): para obtener los índices de las entradas del vector x que satisfacen la condición creada.

- which.min(x): nos da la primera posición en la que el vector x toma su valor mínimo.

- which(x==min(x)): da todas las posiciones en la que el vector x toma su valor máximo

- which.max(x):nos da la primera posición en la que el vector x toma su valor máximo

- which(x==max(x)): da todas las posiciones en las que el vector x toma sus valores máximos.

__ No dirán cuál es el elemento mas grande o cumple una condición, sino que nos darán la posicion en elvector de los elementos que la cumplan.__

```{r mas_ejemplos_subvectores, echo=TRUE}
x =seq(3,50, by= 3.5)
x

x[3] #Posición 3 =10
x[8] #posición 8 = 27.5
x[length(x)] # última posición
x[length(x)-1] # Penúltima posición
x [length(x)-2] # Antepenúltima posición

x[-3] #todo el vector menos la tercera posición
x[4:8] #Los elementos desde la 4 a la 8 posición
x[8:4] #El vector de los elementos entre 4 y 8 en orden inverso.

x[seq(2, length(x), by=2)] # Empieza en la 2 posición hasta el final dando saltos de 2.
x[-seq(2, length(x), by=2)] #Elimina los pares


x[(length(x)-3):length(x)] # Muestra las 3 últimas posiciones antes del final junto con la última posición (4 en total). OJO CON EL PARÉNTESIS [()]

x[c(1,5,6)] # Posiciones 1, 5 y 6
x[x>30] #mayores de 30
x[x>20 & x<40 #mayores que 20 y menores que 40
x[x!=3 & x !=17] #No son iguales a 3 y 17
x[x<19 | x<40] #los menores de 10 por un lado y los mayores de 40 por otro
x[x>=10] #mayor o igual a 10
x[!x<10] #x NO es menor de 10


x[x%%2 ==0] #cuyo resto entre 2 es 0
x[x%%2==1] #cuyo resto entre 2 es 1


x>30 #Te indica si es verdadero o falso (condición Booleana)
x[x>30] #te muestra las posiciones para las que se cumplen la condición booleana.

x= c(1,7,4,2,4,8,9,2,0)
y= c(5,2,-3,-7,-1,4,-2,7,1)
x[y>0] #Elementos de x cuyo análogo en Y son positivos. Siempre que sean de la misma longitud.


which(x>4) #POsiciones
x[which(x>4)] #Elementos
which(x >2 & x< 8) #Posiciones
x[which(x>2 &x<8)] #Elementos
which(x<5 | x%%2==0) #Posiciones
x[which(x<5 | x%%2==0)] #Elementos

which.min(x) #el minimo está en la pos. 9
which (x == min(x)) #si hay más de uno

which.max(x)
which (x ==max(x))
fix(x) #se ha modificado el vector para incluir más maximos
```

#### Si no se cumple la condición:
```{r no_condicion, echo=TRUE}
x[x>4 & x<7] # numeric(0) Inica el tipo de elementos del vector y que está vacío para esa condición.
which(x>4 & x<7) #integer(0) Devuelve posiciones, no números, no sabe de qué tipo son.

```
# Los valores NA (No disponibles)

Podemos pedir si cierta expresi´çon numerica es verdad o no:

```{r prueba_condiciones_booleanas, echo=TRUE}
2^pi>pi^2 # FALSE
2^pi #8.824978
pi^2 # 9.869604

12345678%%9 ==0 #TRUE
12345678/9 #1371742


```



Una funcion aplicada a un vector con un NA tenderá a generar NA's. Sin embargo, se pueden calcular vectores con NA;

$\cdot$ na.rm=TRUE (quita los NA)

La funcion which(x ==NA) NO FUNCIONA.

$\cdot$ is.na(x) Te indica si hay algún valor NA

La función cumsum(x) no admite el valor na.rm. En su lugar, se usa cumsum(x[!is.na(x)]), que los elimina


na.omit(x) Omite los NA del vector, pero siguen estando ahí.
